# 1. Blockchain

## 1. 블록체인이란?

- **블록체인(Blockchain)은** **비즈니스 네트워크** 내에서 거래 기록 및 자산 추적을 용이하게 하는 **변경 불가능한 공유 원장**이다.

  - 네트워크 참여자들은 모두 동일한 정보를 보유하며, 각 거래는 **투명하게 기록**되고, 임의로 변경할 수 없다.
  - 블록체인의 가장 큰 특징은 **분산화(Decentralization)**와 **변조 방지**로, 중앙 권한 없이도 안전하게 데이터를 관리할 수 있다.
  - **비트코인**과 같은 암호화폐뿐만 아니라, 다양한 산업에서 **신뢰 기반 시스템**으로 활용되고 있다.

- **분산 데이터베이스**로 불리며, 수천 대의 컴퓨터(노드)가 네트워크에 참여하여 **동일한 데이터의 복사본**을 보유한다.
  - 이로 인해 네트워크의 **신뢰성**과 **무결성**이 보장되며, 데이터는 **추가만 가능**하고 **수정 또는 삭제는 불가능**하다.
  - 이러한 특성은 거래 내역의 투명성을 보장하고, 데이터 조작을 방지한다.

## 2. 블록(Block)이란?

- **블록(Block)**은 데이터를 저장하는 **기본 단위**로, 블록체인은 **여러 블록이 순차적으로 연결**된 구조를 가지고 있다.

  - 개발 용어로 **Linked List**의 **Node**가 **Block**과 동일한 역할을 하며, 각 블록은 이전 블록과 **체인 형태**로 연결되어 있다.

- 블록체인의 각 블록에는 **거래 정보(transaction data)**, **타임스탬프(timestamp)**, **이전 블록의 해시** 등이 포함된다.

  - **암호학적으로 안전하게 연결**된 블록들은 이전 블록에 대한 **참조(해시)**를 포함하여 일종의 **체인**을 형성하며, 이로 인해 블록 순서를 변경하거나 데이터 조작이 불가능하다.
  - 각 블록은 새롭게 생성될 때마다 **검증 작업(Proof of Work)** 또는 **합의 알고리즘(Consensus Algorithm)**을 통해 네트워크의 합의를 얻고, 정당한 블록으로 인정받아 **블록체인에 추가**된다.

- **블록체인(Blockchain)**이라는 이름은 이와 같이 **블록들이 체인처럼 연결된 구조**에서 유래되었다.
  - 각 블록은 **거래 기록**과 **스마트 계약의 실행 결과** 등 다양한 정보를 저장하며, 이 정보들은 네트워크 참여자들에 의해 **검증**되고 **공유**된다.

## 3. 블록의 구조

- 블록은 주로 **블록 헤더(Block Header)**, **트랜잭션 데이터(Transaction Data)**, **해시 값(Hash Value)**으로 구성된다. 이러한 구조는 블록체인의 데이터 무결성을 보장하고, 안전한 연결을 유지하는 데 중요한 역할을 한다:

  1. **블록 헤더(Block Header)**:

     - 블록 헤더는 블록의 **메타데이터**를 포함하는 부분으로, 다음과 같은 정보들이 담겨 있다:
       - **이전 블록의 해시**: 현재 블록이 참조하는 **이전 블록**의 암호화된 해시 값. 이를 통해 블록 간의 **연결성**이 유지된다.
       - **타임스탬프**: 블록이 생성된 시간으로, 블록의 유효성과 거래의 **시간 순서**를 보장한다.
       - **난이도 값**: 블록을 생성하는 과정에서의 **채굴 난이도**를 나타내는 값. 이는 새로운 블록을 만들기 위해 필요한 계산량을 조정하는 요소이다.
       - **Nonce**: 블록을 채굴하는 과정에서 사용되는 숫자로, 올바른 해시 값을 찾기 위해 여러 값을 시도한 결과이다.

  2. **트랜잭션 데이터(Transaction Data)**:

     - 블록 안에 기록된 거래 내역으로, 각 블록은 수많은 **트랜잭션**을 포함할 수 있다.
     - **스마트 계약(Smart Contract)**의 실행 결과나 **사용자 간의 거래** 내역 등이 여기에 포함된다.
     - 각 트랜잭션은 **디지털 서명**을 통해 보안이 강화되며, 트랜잭션의 무결성이 보장된다.

  3. **해시 값(Hash Value)**:
     - 해시 값은 블록 내 모든 데이터를 기반으로 생성된 **암호화된 고유 식별자**이다.
     - 해시는 각 블록의 데이터를 압축한 **고유한 값**으로, 이를 통해 블록의 데이터가 변경되지 않았음을 확인할 수 있다.
     - 만약 블록 내 데이터가 변조되면 해시 값이 달라지며, 체인의 신뢰성에 문제가 발생한다.

- 블록체인은 **탈중앙화**된 구조로, 중앙 서버 없이도 수천 개의 노드들이 서로 **동일한 데이터를 검증**하고 **동의**하는 방식으로 운영된다.
  - 각 블록은 수많은 **검증 작업**을 거쳐 **블록체인에 추가**되며, 이를 통해 네트워크는 **보안**과 **신뢰성**을 유지한다.

# 2. Ethereum

## 1. 이더리움이란?

- 이더리움은 **암호화폐** 그 자체보다는 **분산된 공공 컴퓨터**의 개념에 가깝다.
- 이더리움은 분산 네트워크에 걸쳐 실행되는 **글로벌 컴퓨터**로, **상태(state)**를 저장하고 유지한다.
- 이더리움의 **상태**는 수천 개의 네트워크 노드에 **복제**된다.
- 이더리움 블록체인의 **새로운 블록**이 생성될 때마다 **상태가 변화**된다.
- **코드에 의해서만 상태가 전이**될 수 있으며, 모든 트랜잭션과 계약은 코드로 실행된다.

## 2. 이더리움의 계정 구조

- 이더리움에는 두 가지 종류의 계정이 존재한다.
  1. **Externally Owned Account (EOA)**:
     - 사람이 소유하고 통제하는 외부 소유 계정.
     - 개인이 보유한 프라이빗 키로 제어되며, **이더(Ether)**를 보낼 수 있다.
  2. **Contract Account**:
     - **코드에 의해 제어**되는 계정.
     - 스마트 계약을 통해 자동으로 실행되며, 외부에서 호출되지 않는 한 스스로 트랜잭션을 생성하지 않는다.

## 3. 상태(State)와 상태 기계

- **이더리움은 상태 기계**이다. 즉, 상태(state)는 블록체인 네트워크에 **분산**되어 저장되고 복제된다.
- 이더리움의 상태는 **모든 종류의 변수**를 저장할 수 있다.
- 각 블록은 네트워크에서 **현재 상태를 변경**하며, 새로운 블록이 추가될 때마다 상태가 업데이트된다.
- 상태는 오직 **스마트 계약 코드**를 통해서만 변화할 수 있다.

## 4. 스마트 계약(Smart Contract)와 코드 실행

- **스마트 계약**은 **이더리움 네트워크 상의 코드**로, 자동으로 실행된다.
- 계약 계정은 특정 조건이 충족되면 그에 따라 **트랜잭션을 실행**하고, 결과를 상태에 반영한다.
- 이러한 스마트 계약을 통해 **분산된 글로벌 컴퓨터**에서 **코드를 배포**하고 실행할 수 있다.

## 5. 추가적으로 알아야 할 개념

- **가스(Gas)**:
  - 이더리움에서 트랜잭션 또는 스마트 계약을 실행할 때 필요한 **수수료** 개념.
  - 네트워크의 과부하를 방지하고, 악의적인 사용을 억제하기 위해 사용된다.
- **이더(Ether)**:
  - 이더리움 네트워크에서 사용하는 **암호화폐**로, 스마트 계약 실행 시 지불하는 **가스 비용**을 결제하는 데 사용된다.
- **EVM (Ethereum Virtual Machine)**:
  - 이더리움 네트워크에서 스마트 계약을 실행하는 **가상 머신**.
  - 모든 노드가 동일한 계산을 수행하여 **상태를 동기화**하며, 이더리움의 핵심 기능을 담당한다.

## 6. 이더리움 블록체인 구조

- 이더리움 블록체인은 여러 블록이 **체인 형태로 연결**된 구조로, 각 블록은 트랜잭션 데이터를 포함하고 있다.
- 각 블록은 다음과 같은 요소로 구성된다:
  - **블록 헤더**:
    - 이전 블록의 해시, 블록 생성 시간, 난이도 값, 블록 해시 등의 메타데이터.
  - **트랜잭션 데이터**:
    - 해당 블록에서 처리된 모든 트랜잭션 내역.
  - **해시 값**:
    - 블록 내 모든 데이터를 기반으로 생성된 암호화된 고유 식별자.

# 3. MetaMask

## 1. MetaMask란?

- **MetaMask**는 **이더리움(Ethereum)** 네트워크에서 **암호화폐 지갑**을 관리하고, **탈중앙화 애플리케이션(DApps)**과 상호작용할 수 있게 해주는 **브라우저 확장 프로그램 및 모바일 앱**이다.

  - MetaMask를 사용하면 사용자는 **이더리움 블록체인**에서 실행되는 **스마트 계약**을 통해 다양한 서비스를 이용할 수 있다.
  - MetaMask는 주로 **이더리움(ETH)** 및 **ERC-20** 토큰을 저장, 전송 및 수신하는 기능을 제공한다.
  - **Google Chrome**, **Firefox**, **Brave** 같은 브라우저에 확장 프로그램으로 설치할 수 있으며, **iOS**와 **Android**에서 모바일 앱으로도 사용 가능하다.

- MetaMask는 **비수탁형 지갑(non-custodial wallet)**으로, 사용자가 **개인 키**를 직접 관리한다.
  - 개인 키는 암호화되어 사용자 기기에 저장되며, 사용자는 자신만의 **시드 문구**로 이를 보호한다.
  - 이러한 방식은 사용자에게 **데이터와 자산에 대한 완전한 통제권**을 부여하지만, 시드 문구를 분실하면 복구가 불가능하다.

## 2. MetaMask의 주요 기능

1. **지갑 생성 및 관리**:

   - MetaMask는 사용자가 **새로운 지갑**을 생성하거나 **기존 지갑을 복구**할 수 있는 기능을 제공한다.
   - 지갑 생성 시 **시드 문구**가 제공되며, 이를 안전하게 보관하는 것이 중요하다.
   - MetaMask는 **다중 계정**을 지원하며, 사용자는 여러 개의 지갑 주소를 생성하고 관리할 수 있다.

2. **이더리움 및 토큰 전송**:

   - MetaMask를 통해 사용자는 **이더리움(ETH)** 및 **ERC-20** 토큰을 다른 지갑으로 전송하거나 수신할 수 있다.
   - 사용자는 이더리움 네트워크 상에서 거래를 할 때 **가스비(Gas Fee)**를 설정할 수 있으며, 거래가 빠르게 처리될 수 있도록 **가스비를 조정**할 수 있다.

3. **DApp과의 상호작용**:

   - MetaMask는 **탈중앙화 애플리케이션(DApp)**과의 연결을 쉽게 할 수 있다.
   - 예를 들어, **Uniswap**과 같은 탈중앙화 거래소(DEX)나 **OpenSea** 같은 NFT 마켓플레이스에 접속하여 MetaMask 지갑을 연결하고, 이더리움 네트워크에서 직접 거래를 수행할 수 있다.
   - 사용자는 DApp에 접속할 때 MetaMask에서 **거래를 확인**하거나 **스마트 계약을 실행**하는 동의를 할 수 있다.

4. **네트워크 선택 및 관리**:

   - MetaMask는 기본적으로 **이더리움 메인넷**에 연결되어 있지만, 사용자는 **테스트 네트워크**(Ropsten, Kovan 등)나 **커스텀 네트워크**(예: Binance Smart Chain)를 추가하여 다른 블록체인 네트워크와도 상호작용할 수 있다.
   - 이는 개발자들이 DApp을 테스트하거나, 다른 블록체인 네트워크에서 자산을 관리할 때 유용하다.

5. **토큰 관리**:
   - MetaMask는 사용자가 **ERC-20** 표준을 따르는 다양한 토큰을 지갑에 추가하여 관리할 수 있게 해준다.
   - 사용자는 특정 토큰의 **스마트 계약 주소**를 입력하여 MetaMask에 새로운 토큰을 추가할 수 있다.

## 3. MetaMask의 보안 및 개인 키 관리

- MetaMask는 사용자가 **개인 키**를 직접 관리하는 **비수탁형 지갑**이기 때문에, 보안과 관련된 몇 가지 중요한 사항들이 있다.

  1. **개인 키와 시드 문구**:

     - 개인 키는 **이더리움 지갑의 소유권**을 나타내며, 이를 통해 거래를 승인하고 서명할 수 있다.
     - MetaMask는 개인 키를 암호화하여 로컬 디바이스에 저장하며, 사용자가 설정한 **비밀번호**로 이를 보호한다.
     - **시드 문구(Seed Phrase)**는 지갑 복구를 위한 문구로, 지갑을 다시 설정하거나 분실한 경우 이를 이용해 지갑을 복구할 수 있다. 시드 문구를 분실하면 지갑에 대한 접근을 복구할 수 없다.

  2. **거래 승인**:

     - MetaMask를 사용하여 DApp과 상호작용할 때, **거래를 승인**하기 전에 거래 세부 정보와 가스비를 확인할 수 있다.
     - 모든 거래는 **사용자 동의** 하에 이루어지며, 스마트 계약의 실행도 MetaMask에서 승인을 받아야만 진행된다.

  3. **피싱 방지**:
     - MetaMask는 **피싱 사이트**를 방지하기 위해 **피싱 탐지 기능**을 제공하며, 사용자들이 의심스러운 웹사이트에 접속할 경우 경고 메시지를 보여준다.
     - 또한, 사용자는 항상 신뢰할 수 있는 DApp과만 상호작용해야 하며, 지갑 연결 요청이 있을 때 주의를 기울여야 한다.

## 4. MetaMask의 역할과 이점

- MetaMask는 **이더리움 생태계**에서 매우 중요한 역할을 하며, 사용자와 **탈중앙화 네트워크** 간의 **게이트웨이** 역할을 한다.

  1. **탈중앙화 금융(DeFi)**:

     - MetaMask는 **DeFi 플랫폼**과의 연결을 지원하여, 사용자가 탈중앙화된 방식으로 금융 서비스를 이용할 수 있게 해준다.
     - 예를 들어, MetaMask를 통해 **Uniswap**에서 토큰을 교환하거나 **Compound**에서 대출을 받을 수 있다.

  2. **NFT 거래**:

     - MetaMask는 **NFT 마켓플레이스**에서 **대체 불가능한 토큰(NFT)**을 사고 팔 때 사용된다.
     - **OpenSea**, **Rarible** 같은 NFT 플랫폼에서 MetaMask를 이용하여 거래를 승인하고 자산을 관리할 수 있다.

  3. **개발자 친화성**:
     - MetaMask는 **개발자들**이 이더리움 기반의 애플리케이션을 개발할 때 쉽게 사용할 수 있도록 **API**를 제공한다.
     - 스마트 계약 개발자들은 MetaMask와 상호작용하는 **웹3(Web3)** 환경을 구축할 수 있으며, 이를 통해 사용자는 DApp과 쉽게 상호작용할 수 있다.

- MetaMask는 **블록체인의 탈중앙화 철학**을 실현하는 도구로, 사용자가 **자산을 완전히 통제**하고 **중앙화된 권한 없이** 이더리움 네트워크와 상호작용할 수 있도록 해준다.

# POS vs POW

**POS(Proof of Stake)**와 **POW(Proof of Work)**는 블록체인의 **합의 알고리즘**으로, 네트워크의 참여자들이 **새로운 블록을 검증**하고 **체인의 무결성**을 유지하는 방식에서 차이가 있습니다. 이 두 방식은 각각의 장단점과 함께 블록체인의 보안 및 에너지 효율성을 다르게 구성합니다.

## 1. POW (Proof of Work, 작업 증명)

**POW**는 블록체인 네트워크에서 새로운 블록을 추가하기 위해 **채굴자(miner)**들이 복잡한 수학 문제를 해결하고, 그에 따른 **작업 증명**을 하는 방식입니다. **비트코인(Bitcoin)**을 포함한 많은 초기 블록체인 네트워크에서 사용됩니다.

### 특징:

- **작업 증명**: 채굴자들은 블록을 추가하기 위해 복잡한 계산 문제를 풀어야 합니다. 문제를 가장 먼저 푼 채굴자가 블록을 추가할 권리를 얻습니다.
- **보상**: 채굴자는 새로운 블록을 추가하는 대가로 **채굴 보상**과 **트랜잭션 수수료**를 받습니다.
- **보안성**: 계산량이 매우 많고, 네트워크를 장악하려면 전체 컴퓨팅 파워의 51%를 제어해야 하므로 보안성이 높습니다. 하지만 **51% 공격**이 발생할 가능성도 배제할 수 없습니다.
- **에너지 소모**: 많은 전력과 자원이 필요합니다. 수많은 컴퓨터가 동시에 문제를 풀려고 시도하는 과정에서 **에너지 효율성**이 낮아지는 단점이 있습니다. 이는 환경 문제로도 지적받고 있습니다.

### 장점:

- 검증된 보안성: 복잡한 계산 문제를 통해 블록이 검증되기 때문에 신뢰도가 높습니다.
- 비트코인, 이더리움(초기) 등에서 오랜 기간 사용되면서 안정성 입증.

### 단점:

- **높은 에너지 소비**: 채굴에 많은 전력이 소모되며, 환경에 부담을 주는 요소가 큽니다.
- **중앙화 위험**: 채굴 장비를 대규모로 갖춘 기업이나 개인이 채굴을 독점할 수 있어, 결과적으로 일부에 의한 중앙화 가능성이 있습니다.

## 2. POS (Proof of Stake, 지분 증명)

**POS**는 **채굴** 대신 **지분(stake)**을 기반으로 새로운 블록을 추가하는 방식입니다. 즉, 블록 생성에 참여하기 위해 일정량의 암호화폐를 **스테이킹(예치)**하고, 그 지분에 따라 **블록 생성 권한**을 얻습니다. 최근 **이더리움 2.0** 업데이트에서 이더리움이 POW에서 POS로 전환했습니다.

### 특징:

- **지분 증명**: 네트워크의 참여자들이 자신의 **지분**을 예치하면, 무작위로 선출된 사람이 블록을 검증하고 보상을 받습니다. 예치한 지분이 많을수록 블록을 추가할 확률이 높아집니다.
- **보상**: 블록 검증자(Validator)는 새로운 블록을 추가한 대가로 **보상**을 받으며, 자신의 지분을 잃을 위험을 감수하면서 네트워크의 신뢰성을 유지합니다.
- **보안성**: 네트워크를 공격하려면 네트워크의 지분의 상당 부분을 확보해야 하기 때문에, 공격 비용이 매우 높아집니다.
- **에너지 절감**: POW와 달리 복잡한 계산이 필요 없기 때문에 **에너지 효율**이 매우 높습니다. 환경 친화적인 합의 알고리즘으로 평가받고 있습니다.

### 생성 방법:

1. **지분 선택**: 네트워크 참여자들이 일정량의 암호화폐를 보유하고 있을 경우, 그들이 블록을 생성할 기회를 얻습니다. 이때 각 참여자의 지분(즉, 보유하고 있는 암호화폐 양)이 클수록 블록을 생성할 가능성이 높아집니다.

2. **검증자(Validator) 선정**: POS 시스템에서는 "검증자"라고 불리는 참여자가 새로운 블록을 제안하고, 다른 검증자들이 이 블록을 검증합니다. 검증자는 네트워크에 일정량의 코인을 잠그고(스테이킹) 블록 생성을 위한 후보가 됩니다.

3. **블록 생성**: 선정된 검증자는 [거래 내역을 검토한 후 블록을 생성](https://github.com/Oh-Kang94/Blockchain_TIL/blob/main/1.%20markdown_child/how_to_make_block_with_POS.md)합니다. 이를 통해 새로운 거래가 네트워크에 기록되며, 해당 검증자는 보상으로 일부 거래 수수료를 받거나 새롭게 발행된 코인을 획득할 수 있습니다.

4. **블록 검증**: 다른 검증자들이 새로 생성된 블록을 확인하고, 문제 없을 시 해당 블록을 승인합니다. 만약 블록이 부정확하거나 악의적인 데이터가 포함되어 있으면 블록 생성자는 벌금을 물거나 스테이킹한 자산을 잃을 수 있습니다.

### 장점:

- **에너지 효율성**: 계산 문제를 풀 필요가 없기 때문에 전력 소비가 거의 없습니다.
- **확장성**: POW보다 더 빠른 트랜잭션 처리와 낮은 비용으로 블록을 생성할 수 있습니다.
- **탈중앙화**: 채굴자에게 의존하는 대신, 누구나 암호화폐를 스테이킹하여 네트워크 참여자가 될 수 있습니다.

### 단점:

- **부자 우대**: 더 많은 지분을 가진 사람에게 블록 생성 권한이 집중될 수 있어 **지분 집중 현상**이 발생할 가능성이 있습니다.
- **초기 보안성 논란**: 네트워크의 지분을 많이 가진 사람이 공격을 감행할 경우, 이론적으로 시스템을 손상시킬 수 있는 위험이 있습니다. 하지만 이는 이중 지불 등의 문제로 인해 **실제 경제적 손실**로 이어질 수 있기 때문에, 이론적인 위험으로 평가되기도 합니다.

## 3. POW와 POS의 비교

| 항목               | POW (Proof of Work)                                  | POS (Proof of Stake)                            |
| ------------------ | ---------------------------------------------------- | ----------------------------------------------- |
| **합의 방식**      | 작업 증명(채굴)                                      | 지분 증명(스테이킹)                             |
| **블록 생성 방식** | 계산 문제 해결을 통해 블록 생성                      | 예치한 지분에 따라 무작위로 블록 생성           |
| **보상 방식**      | 채굴 보상 및 트랜잭션 수수료                         | 검증 보상 및 트랜잭션 수수료                    |
| **에너지 소비**    | 매우 높음                                            | 매우 적음                                       |
| **보안성**         | 높은 계산 능력이 필요하므로 보안성이 높음            | 지분을 많이 가진 사람이 유리하나 공격 비용이 큼 |
| **확장성**         | 트랜잭션 처리 속도가 상대적으로 느림                 | 트랜잭션 처리 속도가 빠르고 확장성 높음         |
| **중앙화 위험**    | 대규모 채굴 장비를 가진 자가 중앙화를 초래할 수 있음 | 부자에게 유리한 구조로 중앙화 가능성 있음       |

## 결론

- **POW**는 높은 보안성과 신뢰성을 제공하지만, **에너지 소비**와 **확장성** 측면에서 한계가 있습니다.
- **POS**는 더 **에너지 효율적**이고 확장성이 뛰어나지만, **지분 집중** 문제로 인해 일부 중앙화 위험이 있을 수 있습니다.

최근 많은 블록체인이 **에너지 효율성과 확장성**을 고려하여 **POS**를 채택하고 있으며, 대표적인 예로 **이더리움 2.0**의 POS 전환이 있습니다.

# Web 3.0

## Web 1.0이란?

**Web 1.0**은 1990년대 초부터 2000년대 초반까지의 **초기 웹**을 의미합니다. 이 시기의 웹은 주로 **정적 웹사이트**로 구성되었으며, 사용자들은 콘텐츠를 단순히 **소비**하는 방식이었습니다. 웹사이트는 정보 제공을 목적으로 만들어졌고, **양방향 상호작용**이 거의 없었습니다.

- **정적 페이지**: HTML과 같은 고정된 콘텐츠를 제공하며, 사용자가 정보를 읽기만 할 수 있었습니다.
- **제한된 참여**: 콘텐츠는 소수의 개발자와 웹사이트 소유자가 제작하고 관리했습니다.

## Web 2.0이란?

**Web 2.0**은 2000년대 중반부터 현재까지의 **상호작용 중심 웹**을 말합니다. 사용자들이 **콘텐츠를 생산**하고 **소통**할 수 있는 플랫폼이 등장하면서 **양방향 커뮤니케이션**이 활발해졌습니다. 블로그, 소셜 네트워크, 위키, 댓글 등 다양한 참여 방식이 Web 2.0의 핵심입니다.

- **사용자 생성 콘텐츠**: 누구나 콘텐츠를 만들고 공유할 수 있습니다. (예: 유튜브, 페이스북)
- **플랫폼 중심**: 대규모 플랫폼(구글, 페이스북 등)이 중심이 되어 **데이터**와 **소유권**을 통제합니다.

## Web 3.0의 정의

**Web 3.0**은 **탈중앙화**와 **개인 정보 보호**를 강화한 차세대 웹으로, 블록체인 기술을 기반으로 한 **분산형 인터넷**을 지향합니다. Web 3.0에서는 사용자가 자신의 **데이터**를 **직접 소유**하고, **플랫폼**이 아닌 **사용자 간 신뢰**에 기반한 상호작용이 이루어집니다.

### 개인정보 & 보안성

Web 3.0에서는 개인정보의 **보안성**과 **프라이버시**가 중요한 이슈로 부각됩니다. 사용자는 자신의 **데이터를 직접 관리**할 수 있으며, **블록체인**을 통해 데이터가 **분산 저장**되고 **암호화**되어 보안성이 강화됩니다. 또한 **중개자 없이** P2P 네트워크를 통해 개인 간 데이터 전송이 가능해지므로, **개인 정보 유출** 가능성이 줄어듭니다.

### 소유권

Web 3.0에서는 **소유권** 개념이 혁신적으로 변화합니다. 사용자들은 디지털 자산을 **직접 소유**하고 **관리**할 수 있으며, 이를 보증하는 기술이 블록체인입니다. 특히 **NFT(Non-Fungible Token)**를 통해 디지털 아트, 음악, 게임 아이템과 같은 자산을 **고유한 형태로 보유**할 수 있으며, 소유권을 입증할 수 있습니다. 또한, **메타버스** 내에서 디지털 자산을 직접 소유하고 **경제적 가치를 창출**할 수 있습니다.

### 탈중앙화

Web 3.0의 가장 중요한 특징 중 하나는 **탈중앙화**입니다. 기존 Web 2.0에서는 데이터와 콘텐츠가 **중앙 서버**에 의해 관리되었지만, Web 3.0에서는 블록체인 기술을 통해 **분산된 네트워크**에서 데이터가 관리됩니다. 이러한 탈중앙화는 중앙 기관이나 기업의 통제가 아닌, **네트워크 참여자**들에 의해 **분산 관리**됨으로써 **검열 저항성**과 **투명성**을 높입니다.

### DAO

**DAO(Decentralized Autonomous Organization)**는 Web 3.0의 **핵심 개념** 중 하나로, **분산형 자율 조직**을 의미합니다. DAO는 **스마트 계약**을 기반으로 작동하며, **중앙 관리자가 없이** 참가자들이 의사결정에 참여할 수 있습니다. 의사결정은 **토큰 보유량**이나 **지분**에 따라 이루어지며, 이를 통해 투명하고 공정한 방식으로 조직이 운영됩니다. DAO는 기업, 프로젝트, 커뮤니티 등 다양한 영역에서 **탈중앙화된 운영**을 가능하게 합니다.

예시 비디오 : https://youtu.be/_9wG4PdevrU?si=S3uf81Y5PnG7imNP

## 예시

Web 3.0에서 사용되는 기술을 바탕으로 몇 가지 구현 방법과 예시를 설명하겠습니다. 각 개념과 연관된 기술을 통해 Web 3.0 애플리케이션을 개발할 수 있습니다.

### 1. **개인정보 & 보안성** 구현

Web 3.0에서는 사용자가 자신의 데이터를 직접 제어하고, 중앙 서버 없이 개인 정보 보호를 강화하는 구조가 중요합니다. 이를 구현하기 위해서는 **블록체인 기술**과 **암호화**가 필수입니다.

#### 구현 방법:

- **블록체인 네트워크**를 사용해 데이터를 **분산 저장**하고, **P2P 네트워크**를 통해 데이터 전송이 이루어지도록 설계.
- 사용자 개인 정보는 **암호화**된 형태로 저장하고, 접근 권한을 가진 사람만 **비대칭 키**로 복호화하여 접근 가능하도록 설정.
- **Zero-Knowledge Proof** 같은 프라이버시 보호 기법을 활용하여, 데이터의 내용을 노출하지 않고도 검증할 수 있는 방식을 도입.

#### 예시 코드 (이더리움 스마트 계약):

```solidity
pragma solidity ^0.8.0;

contract PrivacyProtectedData {
    mapping(address => string) private encryptedData;

    // 데이터를 저장하는 함수 (암호화된 데이터)
    function storeData(string memory _data) public {
        encryptedData[msg.sender] = _data;
    }

    // 저장된 데이터를 가져오는 함수 (암호화된 데이터 반환)
    function getData() public view returns (string memory) {
        return encryptedData[msg.sender];
    }
}
```

이 코드에서 사용자마다 자신이 소유한 데이터를 암호화하여 저장할 수 있고, 다른 사용자는 접근할 수 없습니다.

### 2. **소유권 (NFT)** 구현

**NFT**는 고유한 디지털 자산을 블록체인 상에서 소유하고 거래할 수 있도록 하는 방법입니다. 이는 주로 이더리움 네트워크에서 **ERC-721** 표준을 사용하여 구현됩니다.

#### 구현 방법:

- **ERC-721** 또는 **ERC-1155** 표준을 사용하여 **NFT** 발행.
- **IPFS**와 같은 분산 파일 저장 시스템을 사용하여 NFT의 메타데이터(이미지, 설명 등)를 저장하고 블록체인과 연동.

#### 예시 코드 (ERC-721 기반 NFT):

```solidity
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/utils/Counters.sol";

contract MyNFT is ERC721 {
    using Counters for Counters.Counter;
    Counters.Counter private _tokenIdCounter;

    constructor() ERC721("MyNFT", "MNFT") {}

    // 새로운 NFT를 발행하는 함수
    function mintNFT(address recipient) public {
        _tokenIdCounter.increment();
        uint256 newItemId = _tokenIdCounter.current();
        _mint(recipient, newItemId);
    }
}
```

이 코드는 간단한 NFT를 발행하는 스마트 계약입니다. 각 NFT는 고유하며, 사용자는 이를 소유할 수 있습니다.

### 3. **탈중앙화 애플리케이션 (DApp)** 구현

Web 3.0에서의 **탈중앙화 애플리케이션(DApp)**은 블록체인 기반으로 구축되며, 데이터 저장과 처리 과정이 분산화된 네트워크에서 이루어집니다.

#### 구현 방법:

- **이더리움** 또는 **Solana**와 같은 블록체인 네트워크 위에 **스마트 계약**을 작성하고, 이를 통해 백엔드 로직을 탈중앙화.
- **프런트엔드**는 **React**나 **Vue.js**와 같은 일반 웹 프레임워크를 사용하여, 블록체인 상의 데이터와 상호작용하는 **Web3.js** 라이브러리로 구현.

#### 예시 코드 (DApp의 간단한 React 예시):

```javascript
import React, { useState, useEffect } from "react";
import Web3 from "web3";

function App() {
  const [account, setAccount] = useState(null);

  useEffect(() => {
    loadBlockchainData();
  }, []);

  const loadBlockchainData = async () => {
    const web3 = new Web3(Web3.givenProvider);
    const accounts = await web3.eth.getAccounts();
    setAccount(accounts[0]);
  };

  return (
    <div>
      <h1>My DApp</h1>
      {account ? <p>Connected as: {account}</p> : <p>Not Connected</p>}
    </div>
  );
}

export default App;
```

이 React 코드는 **Web3.js**를 사용하여 이더리움 네트워크에 연결하고, 사용자의 계정 정보를 보여주는 간단한 DApp입니다.

### 4. **DAO(Decentralized Autonomous Organization)** 구현

**DAO**는 사용자들이 탈중앙화된 방식으로 의사결정에 참여할 수 있는 자율 조직입니다. 이를 구현하기 위해 **스마트 계약**을 통해 자동으로 의사결정 절차가 실행되며, 참여자들은 **토큰**을 통해 투표를 할 수 있습니다.

#### 구현 방법:

- DAO 참여자들에게 **거버넌스 토큰**을 발행하고, 이를 기반으로 투표 및 의사결정을 진행.
- **스마트 계약**에서 투표 결과에 따라 자동으로 결정을 집행하는 로직을 구현.

#### 예시 코드 (간단한 투표 기능이 있는 DAO):

```solidity
pragma solidity ^0.8.0;

contract SimpleDAO {
    mapping(address => bool) public members;
    mapping(address => uint256) public votes;
    address public owner;
    bool public proposalPassed;

    constructor() {
        owner = msg.sender;
    }

    // 멤버 추가 함수
    function addMember(address _member) public {
        require(msg.sender == owner, "Only owner can add members");
        members[_member] = true;
    }

    // 투표 함수
    function vote(bool _vote) public {
        require(members[msg.sender], "Not a member");
        if (_vote) {
            votes[msg.sender] = 1;
        } else {
            votes[msg.sender] = 0;
        }
    }

    // 투표 결과 확인 및 제안 실행
    function checkProposal() public {
        uint256 totalVotes = 0;
        uint256 positiveVotes = 0;

        for (uint256 i = 0; i < 10; i++) {
            totalVotes += 1;
            if (votes[address(i)] == 1) {
                positiveVotes += 1;
            }
        }

        if (positiveVotes > totalVotes / 2) {
            proposalPassed = true;
        }
    }
}
```
